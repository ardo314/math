package ardo314:math@0.0.2;

interface types {
    // x, y
    type vector2d = tuple<f32, f32>;

    // x, y, z
    type vector3d = tuple<f32, f32, f32>;

    // x, y, z, w
    type vector4d = tuple<f32, f32, f32, f32>;

    // axis with angle magnitude
    type rotation-vector = tuple<f32, f32, f32>;

    // x, y, z, w
    type quaternion = tuple<f32, f32, f32, f32>;

    // x, y, theta
    type pose2d = tuple<f32, f32, f32>;

    // x, y, z, rx, ry, rz (axis with angle magnitude)
    type pose3d = tuple<f32, f32, f32, f32, f32, f32>;

    // x, y
    type point2d = tuple<f32, f32>;

    // x, y, z
    type point3d = tuple<f32, f32, f32>;

    record plane {
        normal: vector3d,
        d: f32,
    }
}

interface vector2d {
    use types.{vector2d};

    add: func(lhs: vector2d, rhs: vector2d) -> vector2d;
    sub: func(lhs: vector2d, rhs: vector2d) -> vector2d;
    dot: func(lhs: vector2d, rhs: vector2d) -> f32;
    add-f32: func(lhs: vector2d, rhs: f32) -> vector2d;
    sub-f32: func(lhs: vector2d, rhs: f32) -> vector2d;
    mul-f32: func(lhs: vector2d, rhs: f32) -> vector2d;
    div-f32: func(lhs: vector2d, rhs: f32) -> vector2d;
    neg: func(v: vector2d) -> vector2d;
    sqr-length: func(v: vector2d) -> f32;
    length: func(v: vector2d) -> f32;
    normalize: func(v: vector2d) -> vector2d;
}

interface vector3d {
    use types.{vector3d};

    add: func(lhs: vector3d, rhs: vector3d) -> vector3d;
    sub: func(lhs: vector3d, rhs: vector3d) -> vector3d;
    dot: func(lhs: vector3d, rhs: vector3d) -> f32;
    add-f32: func(lhs: vector3d, rhs: f32) -> vector3d;
    sub-f32: func(lhs: vector3d, rhs: f32) -> vector3d;
    mul-f32: func(lhs: vector3d, rhs: f32) -> vector3d;
    div-f32: func(lhs: vector3d, rhs: f32) -> vector3d;
    neg: func(v: vector3d) -> vector3d;
    sqr-length: func(v: vector3d) -> f32;
    length: func(v: vector3d) -> f32;
    normalize: func(v: vector3d) -> vector3d;
    cross: func(lhs: vector3d, rhs: vector3d) -> vector3d;
}

interface vector4d {
    use types.{vector4d};

    add: func(lhs: vector4d, rhs: vector4d) -> vector4d;
    sub: func(lhs: vector4d, rhs: vector4d) -> vector4d;
    dot: func(lhs: vector4d, rhs: vector4d) -> f32;
    add-f32: func(lhs: vector4d, rhs: f32) -> vector4d;
    sub-f32: func(lhs: vector4d, rhs: f32) -> vector4d;
    mul-f32: func(lhs: vector4d, rhs: f32) -> vector4d;
    div-f32: func(lhs: vector4d, rhs: f32) -> vector4d;
    neg: func(v: vector4d) -> vector4d;
    sqr-length: func(v: vector4d) -> f32;
    length: func(v: vector4d) -> f32;
    normalize: func(v: vector4d) -> vector4d;
}

interface rotation-vector {
    use types.{rotation-vector, vector3d, quaternion};

    axis: func(rv: rotation-vector) -> vector3d;
    angle: func(rv: rotation-vector) -> f32;
    to-quaternion: func(rv: rotation-vector) -> quaternion;
}

interface quaternion {
    use types.{quaternion, rotation-vector};

    to-rotation-vector: func(q: quaternion) -> rotation-vector;
}

interface point2d {
    use types.{point2d, vector2d};

    add-vector2d: func(p: point2d, v: vector2d) -> point2d;
    sub-vector2d: func(p: point2d, v: vector2d) -> point2d;
}

interface point3d {
    use types.{point3d, vector3d};

    add-vector3d: func(p: point3d, v: vector3d) -> point3d;
    sub-vector3d: func(p: point3d, v: vector3d) -> point3d;
}

interface pose2d {
    use types.{pose2d, point2d};

    position: func(p: pose2d) -> point2d;
    rotation: func(p: pose2d) -> f32;
}

interface pose3d {
    use types.{pose3d, point3d, rotation-vector};

    position: func(p: pose3d) -> point3d;
    rotation: func(p: pose3d) -> rotation-vector;
}

interface plane {
    use types.{plane};
}

world math {
    export types;
    export vector2d;
    export vector3d;
    export vector4d;
    export rotation-vector;
    export quaternion;
    export point2d;
    export point3d;
    export pose2d;
    export pose3d;
    export plane;
}
