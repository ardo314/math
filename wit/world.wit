package ardo314:math@0.1.0;

interface types {
    type vector2d = tuple<f32, f32>; // x, y
    type vector3d = tuple<f32, f32, f32>; // x, y, z
    type vector4d = tuple<f32, f32, f32, f32>; // x, y, z, w

    type rotation-vector = tuple<f32, f32, f32>; // axis with angle magnitude
    type quaternion = tuple<f32, f32, f32, f32>; // x, y, z, w

    type point2d = tuple<f32, f32>; // x, y
    type point3d = tuple<f32, f32, f32>; // x, y, z

    type pose2d = tuple<f32, f32, f32>; // x, y, theta
    type pose3d = tuple<f32, f32, f32, f32, f32, f32>; // x, y, z, rx, ry, rz (axis with angle magnitude)

    record plane {
        normal: vector3d,
        d: f32,
    }
}

interface vector2d {
    use types.{vector2d};

    add: func(lhs: vector2d, rhs: vector2d) -> vector2d;
    sub: func(lhs: vector2d, rhs: vector2d) -> vector2d;
    dot: func(lhs: vector2d, rhs: vector2d) -> f32;
    mul: func(lhs: vector2d, rhs: f32) -> vector2d;
    div: func(lhs: vector2d, rhs: f32) -> vector2d;
    neg: func(v: vector2d) -> vector2d;
    sqr-length: func(v: vector2d) -> f32;
    length: func(v: vector2d) -> f32;
    normalize: func(v: vector2d) -> vector2d;
}

interface vector3d {
    use types.{vector3d};

    add: func(lhs: vector3d, rhs: vector3d) -> vector3d;
    sub: func(lhs: vector3d, rhs: vector3d) -> vector3d;
    dot: func(lhs: vector3d, rhs: vector3d) -> f32;
    mul: func(lhs: vector3d, rhs: f32) -> vector3d;
    div: func(lhs: vector3d, rhs: f32) -> vector3d;
    neg: func(v: vector3d) -> vector3d;
    sqr-length: func(v: vector3d) -> f32;
    length: func(v: vector3d) -> f32;
    normalize: func(v: vector3d) -> vector3d;
}

interface point2d {
    use types.{point2d, vector2d};

    add-vector2d: func(p: point2d, v: vector2d) -> point2d;
    sub-vector2d: func(p: point2d, v: vector2d) -> point2d;
}

interface point3d {
    use types.{point3d, vector3d};

    add-vector3d: func(p: point3d, v: vector3d) -> point3d;
    sub-vector3d: func(p: point3d, v: vector3d) -> point3d;
}

world math {
    export types;
    export vector2d;
    export vector3d;
    export point2d;
    export point3d;
}
